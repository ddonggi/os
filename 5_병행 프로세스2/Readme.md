**학습개요**

**1. 병행 프로세스 중 협력 프로세스에서 발생할 수 있는 구체적인 문제로 생산자-소비자 문제와 판독기-기록기 문제가 있습니다. 또한 협력 프로세스 사이에는 데이터를 공유하기 위해 통신이 필수인데, 이 과정에서도 다양한 문제가 발생할 수 있습니다. 이번 강의에서는 생산자-소비자 문제, 판독기-기록기 문제의 예를 통해 협력 프로세스의 일반적 구현방법을 학습합니다. 또한 병행 프로세스 사이의 통신을 위한 방법에 대해 논리적 측면에서 살펴봅니다.**

**학습목표**

1. **생산자-소비자 문제를 알아보고, 세마포어를 이용하여 해결할 수 있다.**
2. **판독기-기록기 문제를 알아보고, 세마포어를 이용하여 해결할 수 있다.**
3. **프로세스 간 통신을 위한 논리적 구조를 설명할 수 있다.**

## 생산자-소비자 문제

### 생산자-소비자 문제 정의

두 협력 프로세스 사이에 버퍼를 두고 생산자와 소비자의 상황을 다루는 문제

- 생산자 : 데이터를 넣는 프로세스 (데이터를 버퍼에 넣음)
- 소비자 : 데이터를 꺼내는 프로세스 (버퍼의 데이터를 꺼내서 사용)

```java
생산자 -> | 버퍼 |-> 소비자
```

버퍼라는 공통된 영역을 다룬다 ( 비었을때, 가득찼을때 등의 상황에서 어떻게 할 것인가?)

### 생산자-소비자 문제 조건

버퍼에 여러 프로세스가 동시에 접근할 수 없음

- 버퍼에 데이터를 넣는 동안에는 데이터를 꺼낼 수 없음
- 버퍼에서 데이터를 꺼내는 동안에는 데이터를 넣을 수 없음

→ 상호배제 필요

버퍼의 크기가 유한 (유한 버퍼 문제)

- 버퍼가 가득 찬 경우 생산자는 대기해야 함
- 버퍼가 빈 경우 소비자는 대기해야 함

→ 동기화 필요

### 세마포어를 이용한 해결

상호배제 : 세마포어 mutex (초깃값 1)

```java
생산자의 코드
while(true){
데이터를 생산

P(mutex);
버퍼에 데이터를 넣음 (임계영역)
V(mutex);	
	
}

소비자의 코드
while(true){
P(mutex);
버퍼에서 데이터를 꺼냄 (임계영역)
V(mutex);

데이터를 소비
}
```

상호배제를 해결하기 위해 mutex에 초깃값이 필요하며, 1로 사용을 한다

버퍼가 **가득 찬** 경우 **동기화** : 세마포어 empty (초깃값 n)

```java
생산자의 코드
while(true){
	데이터를 생산
	P(empty);
	P(mutex);
	버퍼에 데이터를 넣음 (임계영역)
	V(mutex);	
	
}

소비자의 코드
while(true){
	P(mutex);
	버퍼에서 데이터를 꺼냄 (임계영역)
	V(mutex);
	V(empty);
	데이터를 소비
}
```

버퍼가 **빈** 경우 **동기화 : 세마포어 full (초깃값0)**

```java
생산자의 코드
while(true){
	데이터를 생산
	P(empty);
	P(mutex);
	버퍼에 데이터를 넣음 (임계영역)
	V(mutex);	
	V(full);
}

소비자의 코드
while(true){
	P(full);
	P(mutex);
	버퍼에서 데이터를 꺼냄 (임계영역)
	V(mutex);
	V(empty);
	데이터를 소비
}
```

## 판독기-기록기 문제

### 판독기-기록기 문제 정의

여러 협력 프로세스 사이에 공유자원을 두고 판독기와 기록기의 상황을 다루는 문제

- 판독기 : 데이터를 읽는 프로세스
- 기록기 : 데이터를 쓰는 프로세스

```java
기록기1                                      판독기1
기록기2 -> 데이터 쓰기 -> 공유자원 -> 데이터 읽기 -> 판독기2
기록기3                                      판독기3
```

### 판독기-기록기 문제 조건

하나의 기록기가 공유자원에 데이터를 쓰는 중에는 다른 **기록기**나 **판독기**는 공유자원에 접근할 수 없음

- 쓰거나 읽을 때 데이터 값이 꼬일 수 있기 때문
- 공유자원에 데이터를 쓰는 동안에는 누구도 접근할 수 없음
- 공유자원에서 데이터를 읽는 동안에는 데이터를 쓸 수 없음

→ 그러기 위해서는 상호배제가 필요

여러 판독기는 동시에 공유자원에서 데이터를 읽을 수 있음

- 판독기가 읽는 중 새로운 판독기 읽기 시도 → 가능
- 판독기가 읽는 중 기록기 대기

→ 새로운 판독기 읽기 시도 → 가능/불가능

### 제1판독기-기록기 문제

판독기가 공유자원에 접근 중이라면 기록기보다 판독기에 우선순위를 줌

즉 새로운 판독기는 즉시 공유자원에 접근 가능

문제점은 기록기의 기아상태 유발 가능(일을 못해서)

### 세마포어를 이용한 해결

상호배제 : 세마포어 wrt(초깃값1)

기록기의 코드

```bash
P(wrt)
공유자원에 쓰기
V(wrt)
```

판독기 우선 코드 :  wrt (초깃값1), 일반변수 rcount(초깃값 0) , 세마포어 mutex ( 초깃값1)

```bash
P (mutex) ;
rcount = rcount + 1;
if (rcount ==1 ) P(wrt);
V (mutex) ;

공유자원에서 읽기

P (mutex) ;
rcount = rcount - 1 ;
if (rcount == 0) V(wrt);
V (mutex) ;
```

### 제2판독기-기록기 문제

판독기가 공유자원에 접근 중이라면 판독기보다 기록기에 우선순위를 줌

즉 대기중인 기록기가 있다면 새로운 판독기는 공유자원에 접근 불가능

문제점은 판독기의 병행성이 떨어짐, 판독기의 기아상태 유발 가능

### 세마포어를 이용한 해결

기록기 우선 코드 : 5개의 세마포어 : rd(1), wrt(1), mutex1(1), mutex2(1), mutex3(1)

```bash
P(mutex2);
wcount = wcount + 1;
if (wcount == 1) P(rd);
V(mutex2);

P(wrt) ;
공유자원에 쓰기
V(wrt) ;

P(mutex2);
wcount = wcount - 1;
if (wcount == 0) V(rd);
V(mutex2);
```

판독기의 코드

```bash
P(mutex3) ;
P(rd);
P(mutex1) ;
rcount = rcount + 1;
if (rcount ==1 ) P(wrt);
V(mutex1) ;
V(rd);
V(mutex3);

공유자원에서 읽기

P(mutex1);
rcount = rcount - 1 ;
if (rcount == 0) V(wrt);
V (mutex1) ;
```

## 프로세스 간 통신

### 프로세스 간 통신(IPC)

InterProcess Communication

병행 프로세스가 데이터를 서로 공유하는 방법

- 공유 메모리 방법
- 메세지 전달방법

하나의 운영체제에서 두 방법 함께 사용 가능

### 공유 메모리 방법

협력 프로세스가 동일한 변수를 사용

- 동일한 변수 : 공유자원인 메모리 공간 사용
- 예) 생산자-소비자 문제의 유한 버퍼, 판독기-기록기 문제의 공유자원

대량 데이터 교환 : 고속 통신 가능

통신상 발생 가능 문제 해결

- 응용 프로그래머

### 메세지 전달 방법

협력 프로세스가 메시지를 주고받음

- 시스템 호출 send(), receive()

메시지를 주고 받기에 소량 데이터 교환에 적합

통신상 발생 가능한 문제 해결

- 운영체제

### 메시지 전달방법의 논리적 구조

통신링크

- 메시지가 지나다니는 통로

프로세스 A ======통신링크====== 프로세스 B

통신링크의 구현 형태

- 연결 대상 : 두 프로세스, 셋 이상 프로세스
- 두 프로세스 사이 링크 개수 : 하나, 둘 이상
- 방향선 : 단방향, 양방향
- 용량 : 무한, 유한, 0

### 통신 링크의 용량

무한 : 큐의 크기가 무한, 송신자는 대기 없음

유한 : 큐의 크기만큼 가득 차면 대기

0 : 큐 없음. 송신사는 수신자가 메시지를 받을 수 있을 때까지 대기

### 직접통신

두 프로세스가 직접 서로를 지정하여 메시지 전달

Send(B, m1) receive(A, m1);

Receive(B, m2); Send(B, m2);

오직 하나의 통신 링크가 자동 설정

하나의 통신 링크는 오직 두 프로세스 사이에만 연관

통신 링크는 양방향

대칭형 주소 지정

- 프로세스 A ==== 프로세스 B
- send(B, m);        receive(A, m);

비대칭형 주소 지정

- 프로세스 A ==== 프로세스 B
- send(B, m);         receive(id, m);
- 수신자가 여러 송신자와 통신 링크를 갖는 경우 사용

### 간접통신

프로세스 사이에 둔 우편함을 통해 메시지 전달

- 프로세스 A ==우편함C== 프로세스 B
- send(C, m);         receive(C, m);
- 같은 우편함을 이용하는 경우 통신 링크가 설정
- 여러 우편함을 이용하면 여러 개의 통신 링크 존재
- 하나의 통신 링크가 여러 프로세스와 연관 가능
- 통신 링크는 단방향 또는 양방향

우편함이 수신 프로세스에 소속

- 수신자 하나
- 통신 링크는 단방향
- 수신 프로세스가 종료하면 우편함도 ㅅ하라짐

우편함이 운영체제에 소속

- 수신자 여럿
- 한 순간에 하나의 수신자만 가능
- 운영체제가 수신자 관리
- 통신 링크는 양방향

**정리하기**

1. **생산자-소비자 문제는 상호배제와 동기화가 필요한 문제로 세마포어를 이용하여 구현할 수 있다.**
2. **판독기-기록기 문제는 기록기는 상호배제가 필요하나 판독기는 상황에 따라 다른 처리가 필요한 문제로 세마포어를 이용하여 구현할 수 있다.**
3.  **판독기-기록기 문제는 특정 상황에서 판독기에 우선순위를 주는 형태의 문제와 기록기에 우선순위를 주는 형태의 문제로 정의할 수 있다.**
4.  **프로세스 간 통신 방법에는 공유 메모리 방법과 메시지 전달 방법이 있다.**
5. **공유 메모리 방법은 협력 프로세스가 공유 메모리를 이용하는 동일한 변수를 사용함으로써 데이터를 서로 공유하는 방법이다.**
6. **메시지 전달방법은 협력 프로세스가 메시지를 주고받으면서 데이터를 서로 공유하는 방법이다.**
7. **메시지 전달방법에는 송신자와 수신자가 직접 서로를 지정하여 메시지를 주고받는 직접통신 방법과 우편함을 통하여 메시지를 주고받는 간접통신 방법이 있다.**
