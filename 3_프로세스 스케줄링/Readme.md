## **학습개요**

**1. 운영체제는 실행할 준비가 된 프로세스들이 CPU를 적절히 배정받아 작업을 효율적으로 처리할 수 있도록 관리해야 하고, 이를 위해 다양한 스케줄링 알고리즘을 활용합니다. 이번 강의에서는 프로세스 스케줄링의 개요와 정책에 대해 살펴보고, 스케줄링 알고리즘의 성능평가 기준과 함께 여러 가지 스케줄링 기법에 대해 학습합니다.**

## **학습목표**

1. **프로세스 스케줄링의 개요와 정책을 설명할 수 있다.**
2. **스케줄링 성능평가 기준을 설명할 수 있다.**
3. **다양한 스케줄링 기법을 설명할 수 있다.**

---

## 1. 프로세스 스케줄링

### 프로세스 스케줄링

스케줄링

- 여러가지 작업의 처리순서를 결정하는 것
    - 프로세스 스케줄링, 디스크 스케줄링 등

프로세스 스케줄링

주어진 프로세스가 여러 개인 경우, 프로세스 처리 순서를 결정하는것

### 스케줄링 단계

시스템에 들어오는 작업(사용자 요청 작업, 운영체제가 만들어내는 작업 등)들이 **작업 큐**에 순서대로 들어오게 된다.

- 상위단계 스케줄링
    - **작업 큐** 내 작업들 중 **어떤것을 먼저 프로세스로 만들 것**인지를 처리하는 것
    - 시스템의 자원을 효율적으로 이용할 수 있도록 함

상위단계 스케줄링을 통해 만들어진 프로세스들이 준비 큐에 들어와서 준비하게 된다.

- **하위단계 스케줄링**
    - **준비 큐** 내에 프로세스를 선택하여 사용 가능한 CPU를 할당(디스패치) 하는역할
    - 수행 주체 : 디스패처(dispatcher)

자원에 부하가 많이 발생하면 프로세스를 일시중지를 시킨다

- 중간단계 스케줄링
    - 시스템에 대한 단기적인 부하를 조절하도록 함

### 스케줄링의 목표

스케줄링 기본 목표

- 공정성
    - 여러 프로세스 중 한 프로세스만 계속 사용한다면 공정성의 문제가 생긴다.
    - 모든 프로세스가 적정 수준에서 CPU 작업을 할 수 있게 함
- 균형
    - 시스템 자원이 충분히 활용될 수 있게 함

운영체제의 유형에 따른 스케줄링의 목표

- 일괄처리 운영체제 : **처리량(주어진 시간에 처리한 프로세스 수)**의 **극대화** / **반환시간(프로세스 생성 시점부터 종료 시점까지의 소요시간)**의 **최소화** / CPU활용의 극대화
- 시분할 운영체제 : 빠른 **응답시간(요청한 시점부터 반응이 시작되는 시점까지의 소요시간)** / 과다한 **대기시간(프로세스가 종료될 때까지 준비 큐에서 기다린 시간의 합)** 방지
- 실시간 운영체제 : 처리기한 맞춤

### 스케줄링 정책

스케줄링의 목표에 따라 우선적으로 고려해야할 기본정인 정책

- **선점 스케줄링 정책**
    - 실행 중인 프로세스에 인터럽트( CPU가 특정 기능을 수행하는 도중에 급하게 다른 일을 처리하고자 할 때 사용할 수 있는 기능)를 걸고 다른 프로세스에 CPU를 할당할 수 있는 스케줄링 방식
    - 높은 우선순위의 프로세스를 우선 처리해야 하는 경우에 유용
        - 실시간 시스템, 시분할 시스템
    - 문맥(CPU의 메든 레지스터와 기타 운영체제에 따라 요구되는 프로세스의 상태) 교환에 따른 오버헤드(어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등) 발생
        - 운영체제는 문맥 교환이 매우 빠르게 실행되도록 만들어져야 함
    - 문맥교환(Context switching) : CPU가 현재 실행하고 있는 프로세스의 문맥을 PCB에 저장하고 다른 프로세스의 PCB로부터 문맥을 복원하는 작업
    - 준비상태로 돌아갈 수 있다.
- **비선점 스케줄링 정책**
    - 자발적으로 CPU를 내놓지 않음
    - 실행 중인 프로세스를 바로 준비상태로 전이시킬 수 **없는** 스케줄링 방식
    - CPU를 항당 받아 실행이 시작된 프로세스는 대기상태나 종료상태로 전이될 때까지 계속 실행상태에 있게 됨
    - 강제적인 문맥교환이 없어 오버헤드가 발생하지 않음
    - 긴 프로세스가 실행 중이라면 짧은 프로세스가 오래 기다리게 되는 경우 발생
    - 준비상태로 바로 돌아갈 수 없다.

### 스케줄링의 평가 기준

- 평균대기시간
    - 각 프로세스가 수행이 완료될 때까지 준비 큐에서 기다리는 시간의 합의 평균값
- 평균반환시간
    - 각  프로세스가 생성된 시점부터 수행이 완료된 시점까지의 소요시간의 평균값

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a547f3e3-72e4-41a6-ac49-91272a3c9030/2e315ab2-3836-4243-9473-48924ad363c1/Untitled.png)

| 프로세스 | A | B |
| --- | --- | --- |
| 대기시간 | 2(0~2) | 3(1~4) |
| 반환시간 | 4(0~4) | 6(1~7) |

## 2. 스케줄링 알고리즘

### FCFS 스케줄링

> First-Come First-Serves
>

비선점 방식

준비 큐에 도착한 순서에 따라 디스패치

| 프로세스 | A | B | C | D |
| --- | --- | --- | --- | --- |
| 도착시각 | 0 | 0 | 0 | 0 |
| CPU사이클 | 7 | 4 | 1 | 3 |

| 프로세스 | A | B | C | D |
| --- | --- | --- | --- | --- |
| 대기시간 | 0 | 7 | 11 | 12 |
| 반환시간 | 7 | 11 | 12 | 15 |

평균대기시간 = 7.5

평균반환시간=11.25

장점

- 가장 간단한 스케줄링 기법

단점

- 짧은 프로세스가 긴 프로세스를 기다리거나 중요한 프로세스가 나중에 수행될 수 있음
    - 시분할 운영체제나 실시간 운영체제에는 부적합
- 프로세스들의 도착순서에 따라 평균반환시간이 크게 변함

### SJF 스케줄링

> Shortest Job First
>

비선점 방식

**준비 큐에서 기다리는** 프로세스 중 **실행시간이 가장 짧다고 예상되는 것**을 먼저 디스패치

| 프로세스 | A | B | C | D |
| --- | --- | --- | --- | --- |
| 도착시각 | 0 | 2 | 4 | 5 |
| CPU사이클 | 7 | 4 | 1 | 3 |

| 프로세스 | A | B | C | D |
| --- | --- | --- | --- | --- |
| 대기시간 | 0 | 9 | 3 | 3 |
| 반환시간 | 7 | 13 | 4 | 6 |

평균대기시간 = 3.75

평균반환시간 = 7.5

장점

- 일괄처리 환경에서 구현하기 쉬엄

단점

- 실제로는 먼저 처리할 프로세스의 CPU 시간을 예상할 수 없음
- 새로 들어온 짧은 프로세스가 긴 프로세스를 기다리거나 중요한 프로세스가 나중에 수행될 수도 있음
    - 시분할 운영체제나 실시간 운영체제에는 부적합

### SRT 스케줄링

> Shortest Remaining Time
>

SJF알고리즘의 선점 방식

준비 큐에서 기다리는 프로세스 중 남은 실행시간이 가장 짧다고 예상되는 것을 먼저 디스패치

| 프로세스 | A | B | C | D |
| --- | --- | --- | --- | --- |
| 도착시각 | 0 | 2 | 4 | 5 |
| CPU사이클 | 7 | 4 | 1 | 3 |

| 프로세스 | A | B | C | D |
| --- | --- | --- | --- | --- |
| 대기시간 | 8 | 1 | 0 | 2 |
| 반환시간 | 15 | 5 | 1 | 5 |

평균대기시간 = 2.75

평균반환시간 = 6.5

장점

- SJF보다 평균대기시간이나 평균반환 시간에서 효율적임

단점

- 실제로는 프로세스의 CPU 시간을 예상할 수 없음
- 각 프로세스의 실행시간 추적, 선점을 위한 문맥교환 등 SJF보다 오버헤드가 큼

### RR 스케줄링

### HRN 스케줄링

### 다단계 피드백 큐 스케줄링

---

## 정리하기

1. **프로세스의 스케줄링을 위해 상위단계, 하위단계 및 중간단계 스케줄링이 사용된다.**
2. **선점 스케줄링 정책은 실행 중인 프로세스에 인터럽트를 걸고 다른 프로세스에 CPU를 할당할 수 있는 스케줄링 방식이고, 비선점 스케줄링 정책은 실행 중인 프로세스를 바로 준비상태로 전이시킬 수 없는 스케줄링 방식이다.**
3. **FCFS 스케줄링은 준비 큐에 도착한 순서에 따라 디스패치하는 비선점 방식의 스케줄링 알고리즘이다.**
4. **SJF 스케줄링은 준비 큐에서 기다리는 프로세스 중 실행시간이 가장 짧다고 예상되는 것을 먼저 디스패치하는 비선점 방식의 스케줄링 알고리즘이다.**
5. **SRT 스케줄링은 준비 큐에서 기다리는 프로세스 중 남은 실행시간이 가장 짧다고 예상되는 것을 먼저 디스패치하는 선점 방식의 알고리즘이다.**
6. **RR 스케줄링은 프로세스가 도착한 순서대로 프로세스를 디스패치하지만 정해진 시간 할당량에 의해 실행을 제한하는 선점 방식의 스케줄링 알고리즘이다.**
7. **HRN 스케줄링은 준비 큐에서 기다리는 프로세스 중 응답비율이 가장 큰 것을 먼저 디스패치하여 실행하는 비선점 방식의 스케줄링 알고리즘이다.**
8. **HRN 스케줄링의 응답비율은 예상실행시간이 짧을수록, 그리고 대기시간이 길수록 커진다.**
9. **다단계 피드백 큐 스케줄링은 입출력 위주의 프로세스가 연산 위주의 프로세스보다 우선권을 갖도록 하는 선점 방식의 알고리즘이다.**
